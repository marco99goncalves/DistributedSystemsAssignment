package ds.assign.chat;

import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.SimpleFormatter;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import poisson.*;

class Pair<T, E> {
    public T key;
    public E value;

    public Pair(T key, E value) {
        this.key = key;
        this.value = value;
    }

    public T getKey() {
        return key;
    }

    public void setKey(T key) {
        this.key = key;
    }

    public E getValue() {
        return value;
    }

    public void setValue(E value) {
        this.value = value;
    }
}

class LamportMessage implements Comparable<LamportMessage>, Serializable {
    int timestamp;
    String message;
    boolean isAck;
    int process;

    public LamportMessage(int timestamp, String message, boolean isAck, int process) {
        this.timestamp = timestamp;
        this.message = message;
        this.isAck = isAck;
        this.process = process;
    }

    @Override
    public int compareTo(LamportMessage other) {
        if (this.timestamp == other.timestamp)
            return Integer.compare(this.process, other.process);
        return Integer.compare(this.timestamp, other.timestamp);
    }
}

public class Peer {

    public static String SERVER_HOST;
    public static int SERVER_PORT;
    public static int WORD_LAMBDA;
    public static int PUSH_PULL_LAMBDA;
    public static String WORD_FILE;
    public static ArrayList<Pair<String, Integer>> TARGETS;
    public static HashMap<String, Pair<String, Integer>> MACHINE_TO_IP;

    public static ConcurrentSkipListSet<LamportMessage> MESSAGE_QUEUE;

    public static JSONObject conf;

    public static ArrayList<String> WORDS_ARRAY;

    public static int CLOCK = 0;
    public static ReentrantLock CLOCK_LOCK;
    public static ReentrantLock QUEUE_LOCK;
    public static String host;
    public static int port;

    Logger logger;

    public Peer(String hostname) {
        logger = Logger.getLogger("logfile");

        try {
            FileHandler handler = new FileHandler("./LOGS/" + hostname + "_peer.log", true);
            logger.addHandler(handler);
            SimpleFormatter formatter = new SimpleFormatter();
            handler.setFormatter(formatter);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void ReadConfigurationFile(String file) {
        JSONParser jsonParser = new JSONParser();
        MACHINE_TO_IP = new HashMap<>();
        try (FileReader reader = new FileReader(file)) {
            //Read JSON file
            Object obj = jsonParser.parse(reader);
            conf = (JSONObject) obj;

            Object serverInfo = conf.get("SERVER");
            JSONArray host_port = (JSONArray) serverInfo;
            SERVER_HOST = (String) host_port.get(0);
            SERVER_PORT = ((Long) host_port.get(1)).intValue();

            JSONObject machinesInfo = (JSONObject) conf.get("MACHINES");
            for (Object machine : machinesInfo.keySet()) {
                String machine_name = (String) machine;
                JSONArray machine_info = (JSONArray) machinesInfo.get(machine_name);
                MACHINE_TO_IP.put((String) machine, new Pair<String, Integer>((String) machine_info.get(0), ((Long) machine_info.get(1)).intValue()));
            }

            WORD_LAMBDA = ((Long) conf.get("WORD_LAMBDA")).intValue();
            PUSH_PULL_LAMBDA = ((Long) conf.get("PUSH_PULL_LAMBDA")).intValue();
            WORD_FILE = conf.get("WORD_FILE").toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void SetupWords() {
        try (BufferedReader br = new BufferedReader(new FileReader(WORD_FILE))) {
            String line;
            while ((line = br.readLine()) != null) {
                WORDS_ARRAY.add(line.trim());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        Peer peer = new Peer(args[0]);
        ReadConfigurationFile("conf_entropy.json");

        System.out.println(WORD_LAMBDA);

        // Setup the connections

        TARGETS = new ArrayList<>();
        for (int i = 0; i < args.length; i++) {
            TARGETS.add(MACHINE_TO_IP.get(args[i]));
        }

        WORDS_ARRAY = new ArrayList<>();
        SetupWords();

        CLOCK_LOCK = new ReentrantLock();
        QUEUE_LOCK = new ReentrantLock();

        Pair<String, Integer> p = MACHINE_TO_IP.get(args[0]);
        host = p.getKey();
        port = p.getValue();

        System.out.printf("new peer @ host=%s\n", args[0]);

        MESSAGE_QUEUE = new ConcurrentSkipListSet<>();

        new Thread(new Server(host, port, peer.logger)).start();

        Thread.sleep(5 * 1000);

        new Thread(new WordGenerator(WORD_LAMBDA)).start();
        new Thread(new Deliverer()).start();
    }
}

class Server implements Runnable {
    String host;
    int port;
    ServerSocket server;
    Logger logger;

    public Server(String host, int port, Logger logger) throws Exception {
        this.host = host;
        this.port = port;
        this.logger = logger;
        server = new ServerSocket(port);
    }

    @Override
    public void run() {
        try {
            logger.info("server: endpoint running at port " + port + " ...");
            while (true) {
                try {
                    Socket client = server.accept();
                    String clientAddress = client.getInetAddress().getHostAddress();

                    new Thread(new Connection(clientAddress, client, logger)).start();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void SendBroadcast(LamportMessage message) throws Exception {
        for (Pair<String, Integer> target : Peer.TARGETS) {
            Socket peerSocket = new Socket(InetAddress.getByName(target.getKey()), target.getValue());

            OutputStream outputStream = peerSocket.getOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(message);
            peerSocket.close();
        }
    }
}

class Connection implements Runnable {
    String clientAddress;
    Socket clientSocket;
    Logger logger;

    public Connection(String clientAddress, Socket clientSocket, Logger logger) {
        this.clientAddress = clientAddress;
        this.clientSocket = clientSocket;
        this.logger = logger;
    }

    @Override
    public void run() {
        try {
            Peer.CLOCK_LOCK.lock();
            Peer.QUEUE_LOCK.lock();
            /*
             * prepare socket I/O channels
             */
            InputStream inputStream = clientSocket.getInputStream();
            ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);

            /*
             * Do stuff with the connection here, for now, nothing though
             */
            LamportMessage message_gotten = (LamportMessage) objectInputStream.readObject();
            clientSocket.close();

            Peer.CLOCK = Math.max(Peer.CLOCK, message_gotten.timestamp) + 1;


            if (!message_gotten.isAck) {
                LamportMessage m = new LamportMessage(Peer.CLOCK, "", true, Peer.port);
                Server.SendBroadcast(m);
            }


            /*synchronized (Peer.MESSAGE_QUEUE) {
                // Adicionar รก queue
                Peer.MESSAGE_QUEUE.add(message_gotten);
                Peer.MESSAGE_QUEUE.notify();
            }*/


            Peer.MESSAGE_QUEUE.add(message_gotten);

            if (ExistsMessageFromAllPeers()) {
                LamportMessage message = Peer.MESSAGE_QUEUE.pollFirst();
                if (!message.isAck) {
                    Peer.CLOCK++;
                    System.out.println(message.message);
                }
            }




            Peer.QUEUE_LOCK.unlock();
            Peer.CLOCK_LOCK.unlock();


            /*
             * close connection
             */
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public boolean ExistsMessageFromAllPeers() {
        HashSet<Integer> counts = new HashSet<>();
        for (LamportMessage message : Peer.MESSAGE_QUEUE) {
            counts.add(message.process);
            if (counts.size() >= Peer.TARGETS.size())
                return true;
        }

        return false;
    }

}

class Deliverer implements Runnable {
    @Override
    public void run() {
        while (true) {
            synchronized (Peer.MESSAGE_QUEUE) {
                try {
                    if (ExistsMessageFromAllPeers()) {
                        LamportMessage message = Peer.MESSAGE_QUEUE.pollFirst();
                        if (!message.isAck) {
                            Peer.CLOCK++;
                            System.out.println(message.message);
                        }
                    }

                    Peer.MESSAGE_QUEUE.wait();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public boolean ExistsMessageFromAllPeers() {
        HashSet<Integer> counts = new HashSet<>();
        for (LamportMessage message : Peer.MESSAGE_QUEUE) {
            counts.add(message.process);
            if (counts.size() >= Peer.TARGETS.size())
                return true;
        }

        return false;
    }
}

class WordGenerator implements Runnable {
    PoissonProcess pp;
    Random random;

    public WordGenerator(int lambda) {
        pp = new PoissonProcess(lambda, new Random());
        this.random = new Random();
    }

    @Override
    public void run() {
        while (true) {
            String word = Peer.port + " " + Peer.MESSAGE_QUEUE.size() + ": " + Peer.WORDS_ARRAY.get(random.nextInt(Peer.WORDS_ARRAY.size()));

            // Send message with the word
            Peer.CLOCK_LOCK.lock();
            Peer.CLOCK++;
            LamportMessage m = new LamportMessage(Peer.CLOCK, word, false, Peer.port);
            Peer.CLOCK_LOCK.unlock();
            // Broadcast the message
            try {
                Server.SendBroadcast(m);
            } catch (Exception e) {
                e.printStackTrace();
            }

            double t_sleep = pp.timeForNextEvent() * 60 * 1000;
            try {
                Thread.sleep((long) t_sleep);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}
